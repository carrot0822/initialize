 树 森林 二叉树 满二叉树 平衡二叉树 线索二叉树 哈夫曼树 转换
 算法：树的遍历 先序 中序 后序 层次 以及序列恢复重组
 ### 树：

 ### 森林：

 需要一个图例

 + 树转换为二叉树 左指针指向第一个孩子结点 右指针指向相邻结点 如此反复即可 由树转换的二叉树没有右子树
 + 森林转换为二叉树
 + 二叉树转换为森林 根节点左子树转为第一颗树的二叉树形式 再把右子树转换为二叉树 慢慢转换 直到没二叉树即可

+ 结点：
+ 路径：一两个结点间经过的序列完成
+ 路径长度：路径上其中经过的边的个数
+ 度数：树中一个结点的子节点树
+ 层次：根节点开始定义 根节点为第一层k
+ 深度：根节点自顶向下累加
+ 高度：叶子结点开始自底向上逐层累加

公式组 
+ Nj = Nd + 1
+ 树中的结点数等于所有结点的度数+1 
+  高度为h的m叉树 至多有mh-1 / m - 1个结点
+ 具有h个结点的m叉树最小高度为 logm(n(m-1) +1) 向上取整

二叉树：每个结点至多两个子树（不存在度大于2的结点 次序不能颠倒 有序树）
+ 性质：
1. 非空二叉树的叶子结点数等于度为2的结点树+1
+ N0 = N2 + 1
+ 结点总数 = 分支数 + 1
+ 结点总数 = N0 + N1 +N2
+ 分支数B = N1 + 2N2
2. 非空二叉树第K层至多有 2^(k-1)个结点
3. 高度为h的二叉树最多有 2^h -1 个结点 最少2^(h-1) + 1个结点

满二叉树：
+ 每个结点度数都为2 
+ 对满二叉树按层序编号 根节点为1 自下而上 从左往右则对于第i个结点 双亲编号为 i/2（向下取整） 如果有的话 左孩子为 2i 右孩子为2i+1 结点个数为 2^h - 1

完全二叉树：高度为h n个结点的二叉树 并且编号与满二叉树一一对应 //满二叉树顺序删减版
#### 特点
1. i《 n/2(向下取整) 则结点i为分支结点 否则为叶子结点
2. 叶子结点只可能在层次最大的两层出现
3. 只存在一个度为1的结点 并且大于其编号i的结点都为叶子结点
4. 若n为奇树 则每个分支结点都有左右孩子 n为偶数则只有编号为 n/2的有左子树
5. 结点编号i 双亲结点为i/2(向下取整) i为偶数 父结点左孩子 i为奇数 为右结点 2i可能是左孩子 2i+1可能是右子树 也可能没有左右孩子
6. 完全二叉树高度为log2(n+1)向上取整
都是编号i与结点树 子节点左右结点的关系 

一个图例

## 树的存储
+ 顺序存储 存储出来就是层次遍历的样子 区别是空缺的结点用0代替
## 树的遍历
+ 前序遍历
+ 中序遍历
+ 后续遍历
+ 层次遍历

#### 二叉排序树：
+ 二叉排序树的创建
+ 二叉排序树的插入
+ 二叉排序树的删除
处理行为之后的失序操作

特点：二叉排序树的中序遍历是一个有小到大的序列
#### 平衡二叉树AVL：
+ 平衡因子 -1 0 1 左正右负 判定的时候把结点包起来
+ 插入
+ 删除
+ 查找
+ 失衡的处理： RR LL RL LR旋转

 哈夫曼树
0. 概念
    + 权
    + 带权路径长度
1. 特点
    + 每个初始结点最后都变成了叶子结点
    + 构造过程共新建结点n - 1 个 哈夫曼树节点总数为 2n -1 个
    + 每次构造新树都选择两棵树作为左右子树 哈夫曼树不存在度为1的结点
    + 哈夫曼树不唯一 但是带权路径长度相同且最优
2. 哈夫曼树的构造(算法 这里需要这个图例)
    + 时间复杂度
    + 空间复杂度
3. 应用
    + 哈夫曼树可用于构造最短的不等长编码方案
4. 哈夫曼编码：如果一组编码中任一编码都不是其他任何一个编码的前缀，我们称这组编码为前缀编码。
 + 意义
 + 应用：哈夫曼编码树中，树的带权路径长度的含义是各个字符的码长与其出现次数的乘积之和，所以采用哈夫曼树构造的编码是一种能使字符串的编码总长度最短的不等长编码。

 存储
 遍历
 算法