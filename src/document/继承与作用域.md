## window对象
需要面试题
1. this指向
this 永远指向最后调用它的那个对象

### this指向的改变
2. 箭头函数 
箭头函数做了什么



箭头函数永远指向外面一层
settimeout 定时器相关  promise相关 事件循环 aysnc await

用途

3. 改变作用域
call 
语法： Function.call(作用域指向，arg1,arg2,arg3)
示例： 
手写call
````javaScript
    var testStr = '指向全局'
    var a={
        testStr:'指向局部'
    }
    function test(name,age){
        this.name= name
        this.age = age
        console.log(this.testStr)
    }
    test('测试','18')
    test.call(a,'测试','18')
    console.log(a)
    console.log(window.name)
    console.log(window.age)
````
apply
语法： Function.apply(作用域指向,[argsArray]) // 传递一个类数组
示例：
手写apply
````javaScript
    var testStr = '指向全局'
    var a={
        testStr:'指向局部'
    }
    function test(name,age){
        this.name= name
        this.age = age
        console.log(this.testStr)
    }
    test('测试','18')
    test.apply(a,['测试','18'])
    console.log(a)
    console.log(window.name)
    console.log(window.age)
````


bind 
语法：Function.bind(作用域指向，arg1,arg2,arg3) 与上述不同的是 会返回原函数的拷贝 并拥有指定的this值和预置参数
示例
手写bind
````javaScript
    var testStr = '指向全局'
    var a={
        testStr:'指向局部'
    }
    function test(name,age){
        this.name= name
        this.age = age
        console.log(this.testStr)
    }
    test('测试','18')
    var bindF = test.bind(a,'测试','18')
    bindF()
    
    test.bind(a,'直接','调用')() // 未运行成功
    console.log(a)
    console.log(window.name)
    console.log(window.age)
````

应用
4. 
对象冒充 
对象调用 
事件绑定 
事件冒泡与周期
jq与js

5. 变量提升
## new所做的事
创建一个空对象 obj;
将新创建的空对象的隐式原型指向其构造函数的显示原型。
使用 call 改变 this 的指向
如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。
````javaScript
var a = new myFunction("Li","Cherry");

new myFunction{
    var obj = {};
    obj.__proto__ = myFunction.prototype;
    var result = myFunction.call(obj,"Li","Cherry");
    return typeof result === 'obj'? result : obj;
}

````
## 普通对象的属性

## new一个对象

## 原型与原型链 作用域与作用域链


## 继承


## es6 class

## 无内鬼 来点3K面试题
// 蛮坑的  不是fn.innerFunction 
    var name = "windowsName";

    function fn() {
        var name = 'Cherry';
        innerFunction();
        function innerFunction() {
            console.log(this.name);      // windowsName
        }
    }

    fn()

````javaScript
function Cat(){
    showName = function(){ // 没有var let 直接提到全局去了
        console.log(1)
    }
    return this
}
console.log(Cat())
console.log(Cat().showName)
Cat.prototype.test = '111'
console.log(Cat.test)// undefined 果然是拿不到的
Cat.showName = function(){
    console.log(2)
}

Cat.prototype.showName = function(){
    console.log(3)
}
// 变量声明提升
var showName = function(){
    console.log(4)
}
function showName(){
    console.log(5)
}
showName() // 打印出4 变量声明提升 理解有丶问题
Cat.showName()// 2
Cat().showName()// 1
new Cat.showName() // 2 
new Cat().showName() // 3 new生成一个新的obj this指向新的obj本身 obj.prototype继承了上面的
new new Cat().showName() // 3
````
/* 变量声明提升
var showName = function(){
    console.log(4)
}
function showName(){
    console.log(5)
}

实际运行结果
var showName
function showName(){
    console.log(5)
}
console.log(showName)
showName = function(){
    console.log(4)
}
*/